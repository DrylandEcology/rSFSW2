
#' Setup infrastructure (skeleton) for a new rSFSW2 simulation experiment
#'
#' @param dir_prj A character string. The path to the new simulation project. Folders are
#'  recursively created if not already existing.
#' @param verbose A logical value.
#' @return Invisibly \code{dir_prj} on success
#'
#' @export
setup_rSFSW2_project_infrastructure <- function(dir_prj, verbose = TRUE) {

  masterinput_pattern <- "_InputMaster_"
  masterinput_pattern_demo <- "_InputMaster_YOURPROJECT_"

  if (verbose) {
    t1 <- Sys.time()
    temp_call <- shQuote(match.call()[1])
    print(paste0("rSFSW2's ", temp_call, ": started at ", t1))
    print(paste("A new rSFSW2 project is prepared for:", sQuote(basename(dir_prj))))

    on.exit({print(paste0("rSFSW2's ", temp_call, ": ended after ",
      round(difftime(Sys.time(), t1, units = "secs"), 2), " s")); cat("\n")}, add = TRUE)
  }

  dir_safe_create(dir_prj)

  # 'definf' object stored in R/sysdata.rda and generated by
  #   data-raw/prepare_default_project_infrastructure.R
  if (exists("definf") && length(definf) == 0)
    stop("No default project infrastructure object located; the installation of the ",
      "package 'rSFSW2' may be faulty.")

  fes <- NULL

  for (di in definf) {
    dtemp <- file.path(dir_prj, di[["path"]])

    if (!dir.exists(dtemp))
       dir_safe_create(dtemp)

    ftemp <- file.path(dtemp, di[["fname"]])

    if (file.exists(ftemp)) {
      fes <- c(fes, ftemp)

    } else {
      if (grepl(masterinput_pattern, di[["fname"]])) {
        # Simulation projects usually rename the input master file: check if present and
        #   if any contain sufficient content
        fim <- list.files(dtemp, pattern = masterinput_pattern)
        fim <- grep(masterinput_pattern_demo, fim, value = TRUE, invert = TRUE)
        fim_ok <- FALSE
        for (kfim in fim) {
          fim_fields <- utils::read.csv(file.path(dtemp, kfim), nrows = 1)
          fim_ok <- fim_ok || all(sapply(required_colnames_SWRunInformation(),
            function(x) x %in% names(fim_fields)))
        }

        if (fim_ok) {
          print(paste("'setup_rSFSW2_project_infrastructure' does not replace the",
            "existing input master file", paste(shQuote(fim), collapse = "/"),
            "with default version of file."))
          next
        }
      }

      writeLines(memDecompress(di[["data"]], type = "gzip", asChar = TRUE),
        con = file.path(dtemp, di[["fname"]]))
    }
  }

  if (!is.null(fes)) {
    fes <- gsub(paste0(dir_prj, "/"), "", fes, fixed = TRUE)
    print(paste("File(s)", paste(shQuote(fes), collapse = ", "), "already existed in",
      "project", shQuote(basename(dir_prj)), "; they were not replaced by default files."))
  }

  if (verbose)
    print(paste("The new rSFSW2 project was successfully prepared at:", sQuote(dir_prj)))


  # Copy demo scripts
  temp <- system.file("demo", package = "rSFSW2")

  ftemps <- list.files(temp, pattern = ".R", full.names = TRUE)
  if (length(ftemps) == 0)
    stop("No folder 'demo' found in package; the installation of the package 'rSFSW2' ",
      "may be faulty.")

  for (f in ftemps)
    file.copy(from = f, to = file.path(dir_prj, basename(f)), overwrite = FALSE)

  invisible(dir_prj)
}


#' Initialize a rSFSW2 project (setup description file)
#'
#' @param SFSW2_prj_meta A list or environment as generated from a file comparable to
#'  \code{file.path(system.file("demo", package = "rSFSW2"), "SFSW2_project_descriptions.R")}
#' @return An updated version of \code{SFSW2_prj_meta}
#'
#' @export
init_rSFSW2_project <- function(SFSW2_prj_meta, fmeta, verbose = TRUE) {
  if (verbose) {
    t1 <- Sys.time()
    temp_call <- shQuote(match.call()[1])
    print(paste0("rSFSW2's ", temp_call, ": started at ", t1))

    on.exit({print(paste0("rSFSW2's ", temp_call, ": ended after ",
      round(difftime(Sys.time(), t1, units = "secs"), 2), " s")); cat("\n")}, add = TRUE)
  }

  #--- Delete objects from 'SFSW2_prj_meta' which were used to create initial input
  suppressWarnings(rm(list = c("d", "dir_big", "dir_ex", "dir_in", "dir_out", "dir_prj",
    "endyr", "scorp", "startyr", "temp"), envir = SFSW2_prj_meta))

  #--- Update project paths and file names
  dir_safe_create(SFSW2_prj_meta[["project_paths"]])

  SFSW2_prj_meta[["fnames_in"]][["fmeta"]] <- fmeta
  SFSW2_prj_meta[["fnames_in"]] <- complete_with_defaultpaths(SFSW2_prj_meta[["project_paths"]],
    SFSW2_prj_meta[["fnames_in"]])

  init_timer(SFSW2_prj_meta[["fnames_out"]][["timerfile"]])

  #--- Update simulation time
  SFSW2_prj_meta[["sim_time"]] <- setup_simulation_time(SFSW2_prj_meta[["sim_time"]],
    add_st2 = TRUE, adjust_NS = SFSW2_prj_meta[["opt_agg"]][["adjust_NorthSouth"]],
    use_doy_range = SFSW2_prj_meta[["opt_agg"]][["use_doy_range"]],
    doy_ranges = SFSW2_prj_meta[["opt_agg"]][["doy_ranges"]]
  )

  #--- Determine scenario names
  SFSW2_prj_meta[["sim_scens"]] <- setup_scenarios(SFSW2_prj_meta[["req_scens"]],
    SFSW2_prj_meta[["sim_time"]][["future_yrs"]])

  #--- Determine requested ensembles across climate scenarios
  SFSW2_prj_meta <- update_scenarios_with_ensembles(SFSW2_prj_meta)

  #--- Prior calculations
  SFSW2_prj_meta[["pcalcs"]] <- convert_to_todo_list(SFSW2_prj_meta[["opt_input"]][["prior_calculations"]])

  #--- External data extraction
  SFSW2_prj_meta[["exinfo"]] <- convert_to_todo_list(SFSW2_prj_meta[["opt_input"]][["req_data"]])

  #--- Matrix to track progress with input preparations
  SFSW2_prj_meta[["input_status"]] <- init_intracker()

  SFSW2_prj_meta
}


gather_project_inputs <- function(SFSW2_prj_meta, use_preprocin = TRUE, verbose = FALSE) {

  #--- Import data
  if (!exists("SFSW2_prj_inputs") || is.null(SFSW2_prj_inputs) ||
    todo_intracker(SFSW2_prj_meta, "load_inputs", "prepared")) {

    SFSW2_prj_inputs <- process_inputs(SFSW2_prj_meta[["project_paths"]],
      SFSW2_prj_meta[["fnames_in"]], use_preprocin, verbose)

    #--- Update output aggregation options
    SFSW2_prj_meta[["opt_agg"]] <- setup_aggregation_options(SFSW2_prj_meta[["opt_agg"]],
      GISSM_species_No = SFSW2_prj_inputs[["GISSM_species_No"]],
      GISSM_params = SFSW2_prj_inputs[["GISSM_params"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "load_inputs", prepared = TRUE,
      checked = !SFSW2_prj_inputs[["do_check_include"]])

    save_to_rds_with_backup(SFSW2_prj_meta, file = SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
  }

  if (all(stats::na.exclude(SFSW2_prj_meta[["input_status"]][, "prepared"])) &&
    exists("SFSW2_prj_inputs")) {
    # Return if all is prepared (from a previous run) and input object exists and haven't
    # been changed since last time ('do_check_include' is FALSE)

    return(list(SFSW2_prj_meta = SFSW2_prj_meta, SFSW2_prj_inputs = SFSW2_prj_inputs))
  }


  #--- Determine size of simulation runs
  if (todo_intracker(SFSW2_prj_meta, "calc_size", "prepared")) {
    SFSW2_prj_meta[["sim_size"]] <- determine_simulation_size(
      SFSW2_prj_inputs[["SWRunInformation"]], SFSW2_prj_inputs[["include_YN"]],
      SFSW2_prj_inputs[["sw_input_experimentals"]], SFSW2_prj_meta[["sim_scens"]])

    SFSW2_prj_meta[["sim_time"]] <- determine_overall_simulation_time(
      st = SFSW2_prj_meta[["sim_time"]], SFSW2_prj_inputs)

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "calc_size", prepared = TRUE, clean_subsequent = TRUE)
  }


  #--- Spatial setup of simulations
  if (todo_intracker(SFSW2_prj_meta, "spatial_setup", "prepared")) {
    SFSW2_prj_meta[["use_sim_spatial"]] <-
      (todo_intracker(SFSW2_prj_meta, "soil_data", "prepared") &&
        (SFSW2_prj_meta[["exinfo"]][["ExtractSoilDataFromCONUSSOILFromSTATSGO_USA"]] ||
        SFSW2_prj_meta[["exinfo"]][["ExtractSoilDataFromISRICWISEv12_Global"]] ||
        SFSW2_prj_meta[["exinfo"]][["ExtractSoilDataFromISRICWISE30secV1a_Global"]])) ||
      (todo_intracker(SFSW2_prj_meta, "elev_data", "prepared") &&
        (SFSW2_prj_meta[["exinfo"]][["ExtractElevation_NED_USA"]] ||
        SFSW2_prj_meta[["exinfo"]][["ExtractElevation_HWSD_Global"]])) ||
      (todo_intracker(SFSW2_prj_meta, "climnorm_data", "prepared") &&
        (SFSW2_prj_meta[["exinfo"]][["ExtractSkyDataFromNOAAClimateAtlas_USA"]] ||
        SFSW2_prj_meta[["exinfo"]][["ExtractSkyDataFromNCEPCFSR_Global"]]))

    SFSW2_prj_meta <- setup_spatial_simulation(SFSW2_prj_meta, SFSW2_prj_inputs,
      use_sim_spatial = SFSW2_prj_meta[["use_sim_spatial"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "spatial_setup", prepared = TRUE, clean_subsequent = TRUE)
  }


  #--- Determine todos for simulation project
  if (todo_intracker(SFSW2_prj_meta, "prj_todos", "prepared")) {

    SFSW2_prj_meta[["prj_todos"]] <- list(
      EstimateConstantSoilTemperatureAtUpperAndLowerBoundaryAsMeanAnnualAirTemperature =
        SFSW2_prj_meta[["pcalcs"]][["EstimateConstantSoilTemperatureAtUpperAndLowerBoundaryAsMeanAnnualAirTemperature"]],
      EstimateInitialSoilTemperatureForEachSoilLayer =
        SFSW2_prj_meta[["pcalcs"]][["EstimateInitialSoilTemperatureForEachSoilLayer"]],

      # output aggregate overall
      aon = convert_to_todo_list(SFSW2_prj_meta[["req_out"]][["overall_out"]]),
      # output aggregate daily
      adaily = setup_mean_daily_output_requests(SFSW2_prj_meta[["req_out"]][["mean_daily"]],
        SFSW2_prj_meta[["opt_agg"]]),
      # output daily traces
      otrace = SFSW2_prj_meta[["req_out"]][["traces"]]
    )

    #--- Update todo list
    SFSW2_prj_meta[["prj_todos"]][["need_cli_means"]] <-
      any(SFSW2_prj_inputs[["sw_input_climscen_values_use"]]) ||
      SFSW2_prj_meta[["prj_todos"]][["EstimateConstantSoilTemperatureAtUpperAndLowerBoundaryAsMeanAnnualAirTemperature"]] ||
      SFSW2_prj_inputs[["sw_input_site_use"]]["SoilTempC_atLowerBoundary"] ||
      SFSW2_prj_inputs[["sw_input_site_use"]]["SoilTempC_atUpperBoundary"] ||
      SFSW2_prj_meta[["prj_todos"]][["EstimateInitialSoilTemperatureForEachSoilLayer"]] ||
      any(SFSW2_prj_inputs[["create_treatments"]] == "PotentialNaturalVegetation_CompositionShrubsC3C4_Paruelo1996") ||
      any(SFSW2_prj_inputs[["create_treatments"]] == "AdjMonthlyBioMass_Temperature") ||
      any(SFSW2_prj_inputs[["create_treatments"]] == "AdjMonthlyBioMass_Precipitation") ||
      any(SFSW2_prj_inputs[["create_treatments"]] == "Vegetation_Biomass_ScalingSeason_AllGrowingORNongrowing")

    # Check that all 'prj_todos' are TRUE or FALSE except exceptions 'adaily' and 'otrace'
    itemp <- names(SFSW2_prj_meta[["prj_todos"]])
    itemp <- itemp[!(itemp %in% c("adaily", "otrace"))]
    temp <- unlist(SFSW2_prj_meta[["prj_todos"]][itemp])
    ibad <- sapply(temp, function(x) !identical(x, TRUE) && !identical(x, FALSE))
    if (any(ibad)) {
      stop("elements of 'prj_todos' should not be 'NULL': ",
      paste(shQuote(names(temp)[ibad]), collapse = ", "))
    }

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "prj_todos", prepared = TRUE)
  }

  list(SFSW2_prj_meta = SFSW2_prj_meta, SFSW2_prj_inputs = SFSW2_prj_inputs)
}


#' Populate rSFSW2 project with input data
#' @export
populate_rSFSW2_project_with_data <- function(SFSW2_prj_meta, opt_behave, opt_parallel,
  opt_chunks, opt_out_run, opt_verbosity) {

  if (opt_verbosity[["verbose"]]) {
    t1 <- Sys.time()
    temp_call <- shQuote(match.call()[1])
    print(paste0("rSFSW2's ", temp_call, ": started at ", t1))

    on.exit({
      print(paste0("rSFSW2's ", temp_call, ": ended after ",
        round(difftime(Sys.time(), t1, units = "secs"), 2), " s with input tracker ",
        "status:"))
      print(SFSW2_prj_meta[["input_status"]])}, add = TRUE)
  }


  #------ PROJECT INPUTS
  temp <- gather_project_inputs(SFSW2_prj_meta,
    use_preprocin = opt_behave[["use_preprocin"]], verbose = opt_verbosity[["verbose"]])
  SFSW2_prj_meta <- temp[["SFSW2_prj_meta"]]
  SFSW2_prj_inputs <- temp[["SFSW2_prj_inputs"]]


  if (all(stats::na.exclude(SFSW2_prj_meta[["input_status"]][, "prepared"])) &&
    exists("SFSW2_prj_inputs")) {
    # Return if all is prepared (from a previous run) and input object exists and haven't
    # been changed since last time ('do_check_include' is FALSE)

    return(list(SFSW2_prj_meta = SFSW2_prj_meta, SFSW2_prj_inputs = SFSW2_prj_inputs))
  }

  # From here on: objects 'SFSW2_prj_meta' and 'SFSW2_prj_inputs' will be manipulated, i.e.,
  #   save them to disk upon exiting function (by error to save intermediate state) or
  #   by final 'return'
  on.exit(save_to_rds_with_backup(SFSW2_prj_meta,
    file = SFSW2_prj_meta[["fnames_in"]][["fmeta"]]), add = TRUE)
  on.exit(save_to_rds_with_backup(SFSW2_prj_inputs,
   file = SFSW2_prj_meta[["fnames_in"]][["fpreprocin"]]), add = TRUE)



  #--- Setup/connect to dbWork
  if (todo_intracker(SFSW2_prj_meta, "dbWork", "prepared")) {
    temp <- setup_dbWork(path = SFSW2_prj_meta[["project_paths"]][["dir_out"]],
      sim_size = SFSW2_prj_meta[["sim_size"]], include_YN = SFSW2_prj_inputs[["include_YN"]],
      resume = opt_behave[["resume"]])

    if (!temp)
      stop("Work database failed to setup or an existing one is from a different",
        "simulation design")

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "dbWork", prepared = TRUE)
  }


  #--- Setup random number generator streams for each runsN_master
  # Note: runsN_master: each site = row of master and not for runsN_total because
  #   same site but under different experimental treatments should have same random numbers

  if (todo_intracker(SFSW2_prj_meta, "rng_setup", "prepared")) {

    SFSW2_prj_meta[["rng_specs"]] <- setup_RNG(
      streams_N = SFSW2_prj_meta[["sim_size"]][["runsN_master"]],
      global_seed = SFSW2_prj_meta[["opt_sim"]][["global_seed"]],
      reproducible = SFSW2_prj_meta[["opt_sim"]][["reproducible"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "rng_setup", prepared = TRUE)

    save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
  }



  #------ EXTERNAL INPUTS
  #------ DAILY WEATHER
  if (todo_intracker(SFSW2_prj_meta, "dbW_paths", "prepared")) {
    SFSW2_prj_meta <- set_paths_to_dailyweather_datasources(SFSW2_prj_meta)

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "dbW_paths", prepared = TRUE)
  }


  #--- Determine sources of daily weather
  if (todo_intracker(SFSW2_prj_meta, "dbW_sources", "prepared")) {

    if (SFSW2_prj_meta[["opt_input"]][["how_determine_sources"]] == "SWRunInformation" &&
      "dailyweather_source" %in% colnames(SFSW2_prj_inputs[["SWRunInformation"]])) {

      dw_source <- factor(SFSW2_prj_inputs[["SWRunInformation"]][SFSW2_prj_meta[["sim_size"]][["runIDs_sites"]], "dailyweather_source"],
        levels = SFSW2_prj_meta[["opt_input"]][["dw_source_priority"]])
      do_weather_source <- anyNA(dw_source)

    } else {
      dw_source <- factor(rep(NA, SFSW2_prj_meta[["sim_size"]][["runsN_sites"]]),
        levels = SFSW2_prj_meta[["opt_input"]][["dw_source_priority"]])
      do_weather_source <- TRUE
    }

    if (do_weather_source) {
      SFSW2_prj_inputs[["SWRunInformation"]] <- dw_determine_sources(dw_source,
        SFSW2_prj_meta[["exinfo"]], SFSW2_prj_meta[["opt_input"]][["dw_source_priority"]],
        SFSW2_prj_inputs, SFSW2_prj_inputs[["SWRunInformation"]],
        SFSW2_prj_meta[["sim_size"]], SFSW2_prj_meta[["sim_time"]], SFSW2_prj_meta[["fnames_in"]],
        SFSW2_prj_meta[["project_paths"]], verbose = opt_verbosity[["verbose"]])

        SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
          tracker = "load_inputs", prepared = TRUE, checked = FALSE)
    }

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "dbW_sources", prepared = TRUE, clean_subsequent = TRUE)

    save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
  }


  #--- Create weather database and populate with weather for current conditions
  if (todo_intracker(SFSW2_prj_meta, "dbW_current", "prepared")) {

    if (SFSW2_prj_meta[["exinfo"]][["ExtractClimateChangeScenarios"]]) {
      SFSW2_prj_meta[["opt_sim"]][["use_dbW_future"]] <- TRUE
      SFSW2_prj_meta[["opt_sim"]][["use_dbW_current"]] <- TRUE
    }
    if (SFSW2_prj_meta[["opt_sim"]][["use_dbW_future"]])
      SFSW2_prj_meta[["opt_sim"]][["use_dbW_current"]] <- TRUE

    if (SFSW2_prj_meta[["opt_sim"]][["use_dbW_current"]]) {
      SFSW2_prj_meta[["sim_size"]] <- update_runIDs_sites_by_dbW(
        sim_size = SFSW2_prj_meta[["sim_size"]],
        label_WeatherData = SFSW2_prj_inputs[["SWRunInformation"]][, "WeatherFolder"],
        fdbWeather = SFSW2_prj_meta[["fnames_in"]][["fdbWeather"]])

      make_dbW(SFSW2_prj_meta, SWRunInformation = SFSW2_prj_inputs[["SWRunInformation"]],
        opt_parallel, opt_chunks, opt_behave,
        deleteTmpSQLFiles = opt_out_run[["deleteTmpSQLFiles"]],
        verbose = opt_verbosity[["verbose"]], print.debug = opt_verbosity[["print.debug"]])

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "dbW_current", prepared = TRUE, clean_subsequent = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])

    } else {
      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "dbW_current", prepared = NA, checked = NA)
    }
  }


  #------ DATA EXTRACTIONS
  #--- Soil data
  if (SFSW2_prj_meta[["exinfo"]][["ExtractSoilDataFromCONUSSOILFromSTATSGO_USA"]] ||
    SFSW2_prj_meta[["exinfo"]][["ExtractSoilDataFromISRICWISEv12_Global"]] ||
    SFSW2_prj_meta[["exinfo"]][["ExtractSoilDataFromISRICWISE30secV1a_Global"]]) {

    if (todo_intracker(SFSW2_prj_meta, "soil_data", "prepared")) {

      SFSW2_prj_inputs <- ExtractData_Soils(SFSW2_prj_meta[["exinfo"]], SFSW2_prj_meta,
        SFSW2_prj_inputs, opt_parallel, resume = opt_behave[["resume"]],
        verbose = opt_verbosity[["verbose"]])

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "soil_data", prepared = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
    }

  } else {
    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "soil_data", prepared = NA, checked = NA)
  }


  #--- Mean monthly climate data
  if (SFSW2_prj_meta[["exinfo"]][["ExtractSkyDataFromNOAAClimateAtlas_USA"]] ||
    SFSW2_prj_meta[["exinfo"]][["ExtractSkyDataFromNCEPCFSR_Global"]]) {

    if (todo_intracker(SFSW2_prj_meta, "climnorm_data", "prepared")) {

      SFSW2_prj_inputs <- ExtractData_MeanMonthlyClimate(SFSW2_prj_meta[["exinfo"]],
        SFSW2_prj_meta, SFSW2_prj_inputs, opt_parallel, opt_chunks,
        resume = opt_behave[["resume"]], verbose = opt_verbosity[["verbose"]])

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "climnorm_data", prepared = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
    }

  } else {
    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "climnorm_data", prepared = NA, checked = NA)
  }


  #--- Topographic data
  if (SFSW2_prj_meta[["exinfo"]][["ExtractElevation_NED_USA"]] ||
    SFSW2_prj_meta[["exinfo"]][["ExtractElevation_HWSD_Global"]]) {

    if (todo_intracker(SFSW2_prj_meta, "elev_data", "prepared")) {

      SFSW2_prj_inputs <- ExtractData_Elevation(SFSW2_prj_meta[["exinfo"]],
        SFSW2_prj_meta, SFSW2_prj_inputs, resume = opt_behave[["resume"]],
        verbose = opt_verbosity[["verbose"]])

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "elev_data", prepared = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
    }

  } else {
    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "elev_data", prepared = NA, checked = NA)
  }


  #--- Climate scenarios and downscaling
  if (SFSW2_prj_meta[["exinfo"]][["ExtractClimateChangeScenarios"]]) {

    if (todo_intracker(SFSW2_prj_meta, "dbW_scenarios", "prepared")) {
      SFSW2_prj_meta[["sim_size"]] <- update_runIDs_sites_by_dbW(
        sim_size = SFSW2_prj_meta[["sim_size"]],
        label_WeatherData = SFSW2_prj_inputs[["SWRunInformation"]][, "WeatherFolder"],
        fdbWeather = SFSW2_prj_meta[["fnames_in"]][["fdbWeather"]])

      temp <- PrepareClimateScenarios(SFSW2_prj_meta, SFSW2_prj_inputs,
        opt_parallel, resume = opt_behave[["resume"]], opt_verbosity, opt_chunks)

      SFSW2_prj_inputs <- temp[["SFSW2_prj_inputs"]]
      SFSW2_prj_meta <- temp[["SFSW2_prj_meta"]] # update: random streams for downscaling

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "dbW_scenarios", prepared = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
    }

  } else {
    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "dbW_scenarios", prepared = NA, checked = NA)
  }



  #------ CALCULATIONS PRIOR TO SIMULATION RUNS

  if (any(unlist(SFSW2_prj_meta[["pcalcs"]])))
    runIDs_adjust <- seq_len(SFSW2_prj_meta[["sim_size"]][["runsN_master"]])  # if not all, then runIDs_sites

  if (SFSW2_prj_meta[["pcalcs"]][["AddRequestedSoilLayers"]]) {
    if (todo_intracker(SFSW2_prj_meta, "req_soillayers", "prepared")) {

      temp <- calc_ExtendSoilDatafileToRequestedSoilLayers(SFSW2_prj_meta, SFSW2_prj_inputs,
        runIDs_adjust, verbose = opt_verbosity[["verbose"]])

      SFSW2_prj_meta <- temp[["SFSW2_prj_meta"]]
      SFSW2_prj_inputs <- temp[["SFSW2_prj_inputs"]]

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "req_soillayers", prepared = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
    }

  } else {
    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "req_soillayers", prepared = NA, checked = NA)
  }


  if (SFSW2_prj_meta[["pcalcs"]][["CalculateBareSoilEvaporationCoefficientsFromSoilTexture"]]) {
    if (todo_intracker(SFSW2_prj_meta, "calc_bsevap", "prepared")) {

      SFSW2_prj_inputs <- get_BareSoilEvaporationCoefficientsForSoilInputFile(
        SFSW2_prj_meta, SFSW2_prj_inputs, runIDs_adjust, resume = opt_behave[["resume"]],
        verbose = opt_verbosity[["verbose"]])

      SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
        tracker = "calc_bsevap", prepared = TRUE)

      save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
    }

  } else {
    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "calc_bsevap", prepared = NA, checked = NA)
  }


  #--- The following will be calculated by each simulation run: set flags here
  # TODO(drs): they require knowledge of site climate which is not available at this point
  #   by the code; such calculations can be carried out here once dbW summarizes/contains
  #   climate variables and SFSW2_prj_inputs can store inputs for each run (instead of
  #   sites and experimentalDesign separately)
  if (SFSW2_prj_meta[["pcalcs"]][["EstimateConstantSoilTemperatureAtUpperAndLowerBoundaryAsMeanAnnualAirTemperature"]]) {

    # Set use-flags so that function 'SiteClimate' is called by each SOILWAT2-run
    SFSW2_prj_inputs[["sw_input_site_use"]]["SoilTempC_atLowerBoundary"] <- TRUE
    SFSW2_prj_inputs[["sw_input_site_use"]]["SoilTempC_atUpperBoundary"] <- TRUE
  }

  if (SFSW2_prj_meta[["pcalcs"]][["EstimateInitialSoilTemperatureForEachSoilLayer"]]) {

    use.layers <- which(SFSW2_prj_inputs[["sw_input_soils_use"]][paste0("Sand_L", SFSW2_glovars[["slyrs_ids"]])])
    index.soilTemp <- paste0("SoilTemp_L", SFSW2_glovars[["slyrs_ids"]])[use.layers]
    SFSW2_prj_inputs[["sw_input_soils_use"]][index.soilTemp] <- TRUE
  }


  #------ OBTAIN INFORMATION FROM TABLES PRIOR TO SIMULATION RUNS
  # As specified by sw_input_treatments and sw_input_experimentals

  if (todo_intracker(SFSW2_prj_meta, "table_lookup", "prepared")) {

    SFSW2_prj_inputs <- do_prior_TableLookups(SFSW2_prj_meta, SFSW2_prj_inputs,
      resume = opt_behave[["resume"]], verbose = opt_verbosity[["verbose"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "table_lookup", prepared = TRUE)

    #save_to_rds_with_backup(SFSW2_prj_meta, SFSW2_prj_meta[["fnames_in"]][["fmeta"]])
  }


  list(SFSW2_prj_meta = SFSW2_prj_meta, SFSW2_prj_inputs = SFSW2_prj_inputs)
}



#' Attempt to check input data of a rSFSW2 project for consistency
#' @export
check_rSFSW2_project_input_data <- function(SFSW2_prj_meta, SFSW2_prj_inputs, opt_chunks,
  opt_verbosity) {

  if (opt_verbosity[["verbose"]]) {
    t1 <- Sys.time()
    temp_call <- shQuote(match.call()[1])
    print(paste0("rSFSW2's ", temp_call, ": started at ", t1))

    on.exit({
        print(paste0("rSFSW2's ", temp_call, ": ended after ",
          round(difftime(Sys.time(), t1, units = "secs"), 2), " s with input tracker ",
          "status:"))
        print(SFSW2_prj_meta[["input_status"]])
      }, add = TRUE)
  }

  if (all(stats::na.exclude(SFSW2_prj_meta[["input_status"]][, "checked"]))) {
    # Return if all is checked (from a previous run)

    return(list(SFSW2_prj_meta = SFSW2_prj_meta, SFSW2_prj_inputs = SFSW2_prj_inputs))
  }

  on.exit(save_to_rds_with_backup(SFSW2_prj_meta,
    file = SFSW2_prj_meta[["fnames_in"]][["fmeta"]]), add = TRUE)
  on.exit(save_to_rds_with_backup(SFSW2_prj_inputs,
    file = SFSW2_prj_meta[["fnames_in"]][["fpreprocin"]]), add = TRUE)


  #--- Checking input 'SWRunInformation'
  if (todo_intracker(SFSW2_prj_meta, "load_inputs", "checked")) {
    # Check that 'dailyweather_source' are specified
    itemp <- SFSW2_prj_inputs[["SWRunInformation"]][SFSW2_prj_meta[["sim_size"]][["runIDs_sites"]], ]
    icheck1 <- !anyNA(itemp[, "dailyweather_source"])
    if (!icheck1) {
      stop("There are sites without a specified daily weather data source. ",
        "Provide data for every requested run.")
    }
  }


  #--- Check daily weather
  if (todo_intracker(SFSW2_prj_meta, "dbW_current", "checked")) {

    if (SFSW2_prj_meta[["opt_sim"]][["use_dbW_current"]] ||
      SFSW2_prj_meta[["opt_sim"]][["use_dbW_future"]]) {

      icheck1 <- file.exists(SFSW2_prj_meta[["fnames_in"]][["fdbWeather"]])
      icheck2 <- check_dbWeather_version(SFSW2_prj_meta[["fnames_in"]][["fdbWeather"]])
      icheck <- icheck1 && icheck2

    } else {
      icheck <- any(all(SFSW2_prj_inputs[["create_treatments"]] == "LookupWeatherFolder"),
      SFSW2_prj_meta[["exinfo"]][["GriddedDailyWeatherFromMaurer2002_NorthAmerica"]],
      SFSW2_prj_meta[["exinfo"]][["GriddedDailyWeatherFromDayMet_NorthAmerica"]])

      if (!icheck) {
        stop("Daily weather data must be provided through 'LookupWeatherFolder', ",
          "'Maurer2002_NorthAmerica', or 'DayMet_NorthAmerica' since no weather database ",
          "is used")
      }
    }

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "dbW_current", checked = icheck)
  }


  #--- Check scenario weather
  if (todo_intracker(SFSW2_prj_meta, "dbW_scenarios", "checked")) {

    icheck <- dbW_sites_with_missingClimScens(
      fdbWeather = SFSW2_prj_meta[["fnames_in"]][["fdbWeather"]],
      site_labels = SFSW2_prj_inputs[["SWRunInformation"]][SFSW2_prj_meta[["sim_size"]][["runIDs_sites"]], "WeatherFolder"],
      scen_labels = SFSW2_prj_meta[["sim_scens"]][["id"]],
      chunk_size = opt_chunks[["ensembleCollectSize"]],
      verbose = opt_verbosity[["verbose"]])

    if (any(icheck)) {
      stop("Daily scenario weather data are not available for n = ", sum(icheck), " sites.")
    }

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "dbW_scenarios", checked = all(!icheck))
  }


  #---- Map input variables (for quality control)
  map_soils <- !isdone_intracker(SFSW2_prj_meta, "soil_data", "checked")
  map_elevs <- !isdone_intracker(SFSW2_prj_meta, "elev_data", "checked")
  map_climnorms <- !isdone_intracker(SFSW2_prj_meta, "climnorm_data", "checked")

  if (any(map_soils, map_elevs, map_climnorms) && !SFSW2_prj_meta[["use_sim_spatial"]]) {
    SFSW2_prj_meta[["use_sim_spatial"]] <- TRUE
    SFSW2_prj_meta <- setup_spatial_simulation(SFSW2_prj_meta, SFSW2_prj_inputs,
      use_sim_spatial = SFSW2_prj_meta[["use_sim_spatial"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "spatial_setup", prepared = TRUE)
  }

  if (map_soils) {
    icheck <- map_input_variables(map_vars = c("SoilDepth", "Matricd", "GravelContent",
      "Sand", "Clay", "TOC_GperKG", "EvapCoeff"), SFSW2_prj_meta, SFSW2_prj_inputs,
      verbose = opt_verbosity[["verbose"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "soil_data", checked = icheck)
  }

  if (map_elevs) {
    icheck <- map_input_variables(map_vars = "ELEV_m", SFSW2_prj_meta, SFSW2_prj_inputs,
      verbose = opt_verbosity[["verbose"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "elev_data", checked = icheck)
  }

  if (map_climnorms) {
    icheck <- map_input_variables(map_vars = c("RH", "SkyC", "Wind", "snowd"),
      SFSW2_prj_meta, SFSW2_prj_inputs, verbose = opt_verbosity[["verbose"]])

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "climnorm_data", checked = icheck)
  }


  #--- Check that INCLUDE_YN* are inclusive
  if (todo_intracker(SFSW2_prj_meta, "load_inputs", "checked")) {
    icheck <- check_requested_sites(
      SFSW2_prj_inputs[["include_YN"]], SFSW2_prj_inputs[["SWRunInformation"]],
      SFSW2_prj_meta[["fnames_in"]], verbose = opt_verbosity[["verbose"]])

    SFSW2_prj_inputs[["SWRunInformation"]] <- icheck[["SWRunInformation"]]

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "load_inputs", checked = icheck[["check"]])
  }


  #--- Check that todos/treatments are coherent
  if (todo_intracker(SFSW2_prj_meta, "prj_todos", "checked")) {
    # Check that overall 'pnv' is turned on if any of the specific ones are
    pnv_temp <- c("PotentialNaturalVegetation_CompositionShrubs_Fraction",
      "PotentialNaturalVegetation_CompositionC3_Fraction",
      "PotentialNaturalVegetation_CompositionC4_Fraction",
      "PotentialNaturalVegetation_CompositionAnnuals_Fraction",
      "PotentialNaturalVegetation_CompositionForb_Fraction",
      "PotentialNaturalVegetation_CompositionBareGround_Fraction",
      "PotentialNaturalVegetation_Composition_basedOnReferenceOrScenarioClimate",
      "AdjMonthlyBioMass_Precipitation",
      "AdjMonthlyBioMass_Temperature",
      "AdjRootProfile",
      "RootProfile_C3",
      "RootProfile_C4",
      "RootProfile_Annuals",
      "RootProfile_Shrubs",
      "RootProfile_Forb")

    icheck <- "PotentialNaturalVegetation_CompositionShrubsC3C4_Paruelo1996" %in%
      SFSW2_prj_inputs[["create_treatments"]] &&
      any(pnv_temp %in% SFSW2_prj_inputs[["create_treatments"]])

    if (any(!icheck)) {
      stop("Calculation and/or adjustement of 'potential natural vegetation' is ",
        "requested for some composition/biomass/root components: the column ",
        "'PotentialNaturalVegetation_CompositionShrubsC3C4_Paruelo1996' is the overall ",
        "gate-keeper for this suit of functionality and must thus be turned on as well ",
        "but is currently not.")
    }

    SFSW2_prj_meta[["input_status"]] <- update_intracker(SFSW2_prj_meta[["input_status"]],
      tracker = "prj_todos", checked = icheck)
  }

  list(SFSW2_prj_meta = SFSW2_prj_meta, SFSW2_prj_inputs = SFSW2_prj_inputs)
}



#' Update todos for simulation project
update_todos <- function(SFSW2_prj_meta, actions, wipe_dbOutput) {
  SFSW2_prj_meta[["prj_todos"]][["actions"]] <- actions
  SFSW2_prj_meta[["prj_todos"]][["use_SOILWAT2"]] <- any(unlist(actions[c("sim_create",
    "sim_execute", "sim_aggregate")]))
  SFSW2_prj_meta[["prj_todos"]][["need_cli_means"]] <- SFSW2_prj_meta[["prj_todos"]][["need_cli_means"]] &&
    SFSW2_prj_meta[["prj_todos"]][["use_SOILWAT2"]]
  SFSW2_prj_meta[["prj_todos"]][["wipe_dbOut"]] <- wipe_dbOutput &&
    !(sum(actions) == 1 && actions[["ensemble"]])
  SFSW2_prj_meta[["prj_todos"]][["do_ensembles"]] <- SFSW2_prj_meta[["sim_scens"]][["has_ensembles"]] &&
    SFSW2_prj_meta[["prj_todos"]][["actions"]][["ensemble"]]

  SFSW2_prj_meta
}


#' Prepare output database without running proper steps of `SFSW2_project_code.R`
#'
#' The need may arise if all/some of input data of your simulation project is located
#' on a remote server and you want to create the output database and work database locally.
#' This function can be called before executing step 3 (\code{populate_rSFSW2_project_with_data})
#' in the demo code "SFSW2_project_code.R".
#'
#' @param path A character string. The path at which the databases will be created --
#'  ignoring the path information from \code{SFSW2_prj_meta} used otherwise.
#'
#' @return Invisibly the number of output fields in the overall aggregation table. Side
#'   effect: creation of \code{dbOutput} and \code{dbWork}.
#' @export
quickprepare_dbOutput_dbWork <- function(actions, path, SFSW2_prj_meta, verbose = FALSE) {

  # Prepare arguments
  temp <- gather_project_inputs(SFSW2_prj_meta, use_preprocin = TRUE, verbose = verbose)
  SFSW2_prj_meta <- temp[["SFSW2_prj_meta"]]
  SFSW2_prj_inputs <- temp[["SFSW2_prj_inputs"]]

  SFSW2_prj_meta <- update_todos(SFSW2_prj_meta, actions, wipe_dbOutput = FALSE)

  # Create dbWork
  setup_dbWork(path = path, sim_size = SFSW2_prj_meta[["sim_size"]],
    include_YN = SFSW2_prj_inputs[["include_YN"]], resume = FALSE)

  # Create dbOutput
  SFSW2_prj_meta[["fnames_out"]][["dbOutput"]] <- file.path(path, "dbTables.sqlite3")
  ncol_dbOut_overall <- make_dbOutput(SFSW2_prj_meta, SFSW2_prj_inputs,
    verbose = verbose)

  invisible(ncol_dbOut_overall)
}



#' Carry out a rSFSW2 simulation experiment
#' @export
simulate_SOILWAT2_experiment <- function(actions, SFSW2_prj_meta, SFSW2_prj_inputs,
  t_job_start, opt_behave, opt_parallel, opt_chunks, opt_out_run, opt_verbosity) {

  t1 <- Sys.time()

  if (opt_verbosity[["verbose"]]) {
    temp_call <- shQuote(match.call()[1])
    print(paste0("rSFSW2's ", temp_call, ": started at ", t1,
      " for project ", sQuote(basename(SFSW2_prj_meta[["project_paths"]][["dir_prj"]]))))

    on.exit({print(paste0("rSFSW2's ", temp_call, ": ended after ",
      round(difftime(Sys.time(), t1, units = "secs"), 2), " s")); cat("\n")}, add = TRUE)
  }


  #--------------------------------------------------------------------------------------#
  #------------------------PREPARE SOILWAT2 SIMULATIONS

  #--- Set up parallelization
  # used in:
  #   - loop calling do_OneSite
  #   - ensembles
  setup_SFSW2_cluster(opt_parallel,
    dir_out = SFSW2_prj_meta[["project_paths"]][["dir_prj"]],
    verbose = opt_verbosity[["verbose"]],
    print.debug = opt_verbosity[["print.debug"]])
  on.exit(exit_SFSW2_cluster(verbose = opt_verbosity[["verbose"]]),
    add = TRUE)
  on.exit(set_full_RNG(SFSW2_prj_meta[["rng_specs"]][["seed_prev"]],
    kind = SFSW2_prj_meta[["rng_specs"]][["RNGkind_prev"]][1],
    normal.kind = SFSW2_prj_meta[["rng_specs"]][["RNGkind_prev"]][2]),
    add = TRUE)


#  # Assigning objects from 'SFSW2_prj_meta' to function environment for the time being;
#  # a hack for convience
#  for (k in ls(SFSW2_prj_meta))
#    assign(k, SFSW2_prj_meta[[k]], envir = environment())

  ow_prev <- set_options_warn_error(opt_verbosity[["debug.warn.level"]],
    opt_verbosity[["debug.dump.objects"]], project_paths[["dir_prj"]],
    verbose = opt_verbosity[["verbose"]])
  on.exit(options(ow_prev), add = TRUE)


  #--- Update todos for simulation project
  SFSW2_prj_meta <- update_todos(SFSW2_prj_meta, actions,
    wipe_dbOutput = opt_out_run[["wipe_dbOutput"]])

  #--- Determine which runs (still) need to be done for this round
  stopifnot(dbWork_clean(SFSW2_prj_meta[["project_paths"]][["dir_out"]]))
  SFSW2_prj_meta[["sim_size"]][["runIDs_todo"]] <- dbWork_todos(SFSW2_prj_meta[["project_paths"]][["dir_out"]]) # elements of runIDs_total
  SFSW2_prj_meta[["sim_size"]][["runsN_todo"]] <- length(SFSW2_prj_meta[["sim_size"]][["runIDs_todo"]])


  #--------------------------------------------------------------------------------------#
  #------------ORGANIZE DATABASES FOR SIMULATION OUTPUT

  SFSW2_prj_meta[["sim_size"]][["ncol_dbOut_overall"]] <- make_dbOutput(SFSW2_prj_meta,
    SFSW2_prj_inputs, verbose = opt_verbosity[["verbose"]])


  #--------------------------------------------------------------------------------------#
  #------------------------RUN RSOILWAT

  # print system information
  temp <- utils::sessionInfo()
  if (opt_verbosity[["verbose"]])
    print(temp)

  if (opt_behave[["check_blas"]])
    benchmark_BLAS(temp$platform)


  # run the simulation experiment
  if (SFSW2_prj_meta[["prj_todos"]][["use_SOILWAT2"]] &&
    SFSW2_prj_meta[["sim_size"]][["runsN_todo"]] > 0) {

    swof <- rSOILWAT2::sw_out_flags()
    swDataFromFiles <- read_SOILWAT2_FileDefaults(SFSW2_prj_meta[["project_paths"]][["dir_in_sw"]])
    args_do_OneSite <- gather_args_do_OneSite(SFSW2_prj_meta, SFSW2_prj_inputs)

    runs.completed <- run_simulation_experiment(SFSW2_prj_meta[["sim_size"]],
      SFSW2_prj_inputs, MoreArgs = args_do_OneSite)

  } else {
    runs.completed <- 0
  }


  #--------------------------------------------------------------------------------------#
  # NOTE(drs): 'concatenation' may be much faster if temporary text files are not constructed
  # around SQL insert statements, but instead as data.frames. Text files containing
  # data.frames may be much faster with checks for duplicate P_id entries and could be
  # inserted at once (instead of line by line) with the command
  #   RSQLite::dbWriteTable(con, name = table, value = "path/to/db-file", append = TRUE)

  # NOTE: The variables 'pids_inserted' and 'pids2_inserted' become quickly very large and
  #   may then be too large for available memory

  t.outputDB <- Sys.time()

  if (actions[["concat_dbOut"]]) {

    has_time_to_concat <- {difftime(t.outputDB, t_job_start, units = "secs") +
      opt_parallel[["opt_job_time"]][["one_concat_s"]]} <
      opt_parallel[["opt_job_time"]][["wall_time_s"]]

    if (has_time_to_concat) {
      move_temporary_to_outputDB(SFSW2_prj_meta, t_job_start, opt_parallel, opt_behave,
        opt_verbosity)

    } else {
      print(paste("Need at least", opt_parallel[["opt_job_time"]][["one_concat_s"]],
        "seconds to put SQL in output DB."))
    }


    if (SFSW2_prj_meta[["opt_out_fix"]][["dbOutCurrent_from_dbOut"]] &&
      !SFSW2_prj_meta[["opt_out_fix"]][["dbOutCurrent_from_tempTXT"]]) {

      has_time_to_concat <- {difftime(Sys.time(), t_job_start, units = "secs") +
        opt_parallel[["opt_job_time"]][["one_concat_s"]]} <
        opt_parallel[["opt_job_time"]][["wall_time_s"]]

      if (has_time_to_concat) {
        do_copyCurrentConditionsFromDatabase(SFSW2_prj_meta[["fnames_out"]][["dbOutput"]],
          SFSW2_prj_meta[["fnames_out"]][["dbOutput_current"]],
          verbose = opt_verbosity[["verbose"]])

      } else {
        print(paste("Need at least", opt_parallel[["opt_job_time"]][["one_concat_s"]],
          "seconds to put SQL in output DB."))
      }
    }
  }

  #timing of outputDB
  delta.outputDB <- as.double(difftime(Sys.time(), t.outputDB, units = "secs"))


  oe <- sys.on.exit()
  oe <- remove_from_onexit_expression(oe, "exit_SFSW2_cluster")
  on.exit(eval(oe), add = FALSE)


  #---------------------------------------------------------------------------------------#
  #------------------------OVERALL TIMING
  delta.overall <- difftime(Sys.time(), t1, units = "secs")

  compile_overall_timer(SFSW2_prj_meta[["fnames_out"]][["timerfile"]],
    SFSW2_prj_meta[["project_paths"]][["dir_out"]], SFSW2_glovars[["p_workersN"]],
    runs.completed, SFSW2_prj_meta[["sim_scens"]][["N"]], 0, delta.overall, delta.outputDB,
    0, 0)


  #---------------------------------------------------------------------------------------#
  if (opt_verbosity[["verbose"]])
    print(utils::sessionInfo())


  SFSW2_prj_meta
}
